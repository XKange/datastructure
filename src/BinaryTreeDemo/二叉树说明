今天对着别人写的代码, 简单敲了一遍用Java实现二叉树,
包括二叉树的创建，求二叉树的高，求二叉树的节点数，二叉树的先序、中序、后序遍历。
感觉二叉树中最关键的思想是递归，这点很重要。
比如求二叉树的高度，可以看做求左、右子树的高度中的最大值加1。
求二叉树的节点个数，可以看做求左、右子树的节点个数之和加1。

5.求二叉树中第k层节点的个数
第k层的节点数等于 第k-1层的节点的左孩子和右孩子相加。

6.判断二叉树是否是平衡二叉树
平衡二叉树概念：平衡二叉树（Balanced Binary Tree）又被称为AVL树（有别于AVL算法），且具有以下性质：它是一 棵空树或它的左右两个子树的高度差的
绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。这个方案很好的解决了二叉查找树退化成链表的问题，把插入，查找，删除的时间复杂度最好情况和最坏情况
都维持在O(logN)。但是频繁旋转会使插入和删除牺牲掉O(logN)左右的时间，不过相对二叉查找树来说，时间上稳定了很多。
递归解法：
（1）如果二叉树为空，返回真
（2）如果二叉树不为空，如果左子树和右子树都是AVL树并且左子树和右子树高度相差不大于1，返回真，其他返回假

7.判断二叉树是否是完全二叉树
完全二叉树概念：叶节点只能出现在最下层和次下层，并且最下面一层的结点都集中在该层最左边的若干位置的二叉树。
若设二叉树的深度为h，除第h层外，其它各层 (1～h-1) 的结点数都达到最大个数，第h层所有的结点都连续集中在最左边，这就是完全二叉树。
有如下算法，按层次（从上到下，从左到右）遍历二叉树，当遇到一个节点的左子树为空时，则该节点右子树必须为空，且后面遍历的节点左
右子树都必须为空，否则不是完全二叉树。

8.两个二叉树是否完全相同
算法：（1）若都为空，则返回true；
（2）若其中一个为空，则返回false；
（3）若该节点的值不相同则，返回false；
（4）boolean left = 从左子树进入递归；
            right = 从右子树进入递归；
（5）返回 left和right相与的值。

9.两个二叉树是否互为镜像

10.翻转二叉树or镜像二叉树

11.求两个二叉树的最低公共祖先节点

15.前序遍历和后序遍历构造二叉树

16.在二叉树中插入节点